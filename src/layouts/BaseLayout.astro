---
import '../styles/global.css';

interface Props {
  title?: string;
  description?: string;
}

const {
  title = "Lead Time GTM - Accelerate Your Go-To-Market Strategy",
  description = "Reduce time-to-market and accelerate growth with data-driven go-to-market strategies.",
} = Astro.props;

const canonicalURL = new URL(Astro.url.pathname, Astro.site || "https://leadtimetgtm.com");
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- Primary Meta Tags -->
    <title>{title}</title>
    <meta name="title" content={title} />
    <meta name="description" content={description} />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content={canonicalURL.href} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content={canonicalURL.href} />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    
    <!-- Canonical URL -->
    <link rel="canonical" href={canonicalURL.href} />
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <slot />
    
    <!-- Section Observer Script -->
    <script>
      // Intersection Observer for scroll animations - optimized
      (function() {
        // Ultra-fast intersection observer with immediate triggers
        const observerOptions = {
          root: null,
          rootMargin: '-5% 0px -5% 0px', // Trigger earlier
          threshold: [0, 0.05, 0.1, 0.15] // Multiple thresholds for snappier response
        };

        const observer = new IntersectionObserver((entries) => {
          // Use requestAnimationFrame for buttery smooth updates
          requestAnimationFrame(() => {
            entries.forEach(entry => {
              if (entry.isIntersecting && entry.intersectionRatio > 0.05) {
                // Add class immediately for instant response
                entry.target.classList.add('visible');
                
                // Update URL hash (defer to avoid blocking)
                const id = entry.target.id;
                if (id && id !== 'main-content') {
                  const newHash = `#${id}`;
                  if (window.location.hash !== newHash) {
                    // Use microtask for non-blocking update
                    Promise.resolve().then(() => {
                      history.replaceState(null, '', newHash || window.location.pathname);
                    });
                  }
                }
                
                // Dispatch event (async to not block rendering)
                Promise.resolve().then(() => {
                  entry.target.dispatchEvent(new CustomEvent('section-viewed', {
                    detail: { sectionId: entry.target.id }
                  }));
                });
              }
            });
          });
        }, observerOptions);

        // Observe all sections on load
        document.addEventListener('DOMContentLoaded', () => {
          document.querySelectorAll('[data-section]').forEach(section => {
            observer.observe(section);
          });
        });

        // Also handle dynamically added sections
        const observerConfig = { childList: true, subtree: true };
        const mutationObserver = new MutationObserver((mutations) => {
          mutations.forEach(() => {
            document.querySelectorAll('[data-section]:not(.observed)').forEach(section => {
              section.classList.add('observed');
              observer.observe(section);
            });
          });
        });

        if (document.body) {
          mutationObserver.observe(document.body, observerConfig);
        } else {
          document.addEventListener('DOMContentLoaded', () => {
            mutationObserver.observe(document.body, observerConfig);
          });
        }
      })();

      // Ultra-smooth scrolling with custom easing
      function smoothScrollTo(element, offset = 165) {
        const start = window.pageYOffset;
        const target = element.getBoundingClientRect().top + window.pageYOffset - offset;
        const distance = target - start;
        const duration = Math.min(Math.abs(distance) * 0.4, 600); // Faster, max 600ms
        let startTime = null;
        
        function easeInOutCubic(t) {
          return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function animation(currentTime) {
          if (startTime === null) startTime = currentTime;
          const timeElapsed = currentTime - startTime;
          const progress = Math.min(timeElapsed / duration, 1);
          
          window.scrollTo(0, start + distance * easeInOutCubic(progress));
          
          if (progress < 1) {
            requestAnimationFrame(animation);
          }
        }
        
        requestAnimationFrame(animation);
      }

      // Keyboard navigation support - optimized
      let scrollTimeout = null;
      document.addEventListener('keydown', (e) => {
        if (scrollTimeout) return; // Prevent rapid scrolling
        
        const sections = Array.from(document.querySelectorAll('[data-section]'));
        const viewportCenter = window.innerHeight / 2;
        let targetSection = null;
        
        if (e.key === 'ArrowDown' || e.key === 'PageDown') {
          targetSection = sections.find(section => {
            const rect = section.getBoundingClientRect();
            return rect.top > viewportCenter;
          });
          if (!targetSection && sections.length > 0) {
            targetSection = sections[sections.length - 1];
          }
        } else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
          targetSection = [...sections].reverse().find(section => {
            const rect = section.getBoundingClientRect();
            return rect.bottom < viewportCenter;
          });
          if (!targetSection && sections.length > 0) {
            targetSection = sections[0];
          }
        } else if (e.key === 'Home') {
          targetSection = sections[0];
        } else if (e.key === 'End') {
          targetSection = sections[sections.length - 1];
        }
        
        if (targetSection) {
          smoothScrollTo(targetSection);
          scrollTimeout = setTimeout(() => { scrollTimeout = null; }, 500); // Faster response time
        }
      });

      // Scroll-to-next button handler - optimized
      document.addEventListener('click', (e) => {
        const button = e.target.closest('[data-scroll-next]');
        if (button) {
          const currentSection = button.closest('[data-section]');
          if (currentSection) {
            const sections = Array.from(document.querySelectorAll('[data-section]'));
            const currentIndex = sections.indexOf(currentSection);
            if (currentIndex < sections.length - 1) {
              smoothScrollTo(sections[currentIndex + 1]);
            }
          }
        }
      });
    </script>
  </body>
</html>

